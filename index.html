<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2026 开启新年好运</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: #00ffcc; font-family: 'Microsoft YaHei', sans-serif; }
        #timer {
            position: absolute; left: 50%; transform: translate(-50%, -50%);
            font-weight: bold; text-shadow: 0 0 20px #00ffcc;
            transition: all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1); z-index: 100;
            pointer-events: none;
        }
        .timer-top { top: 8%; font-size: 24px; opacity: 0.8; }
        .timer-center { top: 50%; font-size: 60px; color: #f1c40f; text-shadow: 0 0 40px #f1c40f; width: 100%; text-align: center; }
        #btn-start {
            position: absolute; z-index: 101; padding: 15px 35px; font-size: 20px;
            background: transparent; color: #00ffcc; border: 2px solid #00ffcc; border-radius: 50px;
            cursor: pointer; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-weight: bold; transition: 0.3s; box-shadow: 0 0 15px rgba(0,255,204,0.3);
        }
        #btn-start:hover { background: #00ffcc; color: #000; }
        canvas { position: absolute; top: 0; left: 0; z-index: 5; }
        video { display: none; }
        .hint {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(0, 255, 204, 0.4); font-size: 12px; letter-spacing: 1px; z-index: 10;
        }
    </style>
</head>
<body>

<button id="btn-start">开启新年“好运”</button>
<div id="timer" class="timer-top">00:00:00</div>
<div class="hint">前置镜头已就绪 · 左右挥手切图 · 张开手掌有惊喜</div>

<video id="video-input" playsinline></video>
<canvas id="main-canvas"></canvas>

<script>
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d', { alpha: false });
const videoElement = document.getElementById('video-input');
const timerText = document.getElementById('timer');

let particles = [];
let targetState = 0;
let currentImgIdx = 0;
let isCooldown = false;
let isTransitioning = false;

const imgSources = ['rs.jpg', '6.jpg', '7.jpg', 'me.jpg'];
const imgBuffers = [];

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

class Particle {
    constructor(ox, oy, tx, ty) {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.ox = ox; this.oy = oy;
        this.tx = tx; this.ty = ty;
        this.r = 0; this.g = 255; this.b = 204;
        this.tr = 0; this.tg = 255; this.tb = 204;
        this.v = 0.06 + Math.random() * 0.06;
    }
    update() {
        let dx = (targetState === 0) ? this.ox : this.tx;
        let dy = (targetState === 0) ? this.oy : this.ty;
        if (isTransitioning) {
            dx += (Math.random() - 0.5) * 60;
            dy += (Math.random() - 0.5) * 60;
        }
        this.x += (dx - this.x) * this.v;
        this.y += (dy - this.y) * this.v;
        this.r += (this.tr - this.r) * 0.1;
        this.g += (this.tg - this.g) * 0.1;
        this.b += (this.tb - this.b) * 0.1;
    }
    draw() {
        ctx.fillStyle = `rgb(${this.r|0},${this.g|0},${this.b|0})`;
        ctx.fillRect(this.x, this.y, 2.2, 2.2);
    }
}

async function loadAllImages() {
    for (let src of imgSources) {
        const data = await new Promise(res => {
            const img = new Image();
            img.src = src;
            img.crossOrigin = "anonymous";
            img.onload = () => {
                const cvs = document.createElement('canvas');
                cvs.width = cvs.height = 300;
                const c = cvs.getContext('2d');
                c.drawImage(img, 0, 0, 300, 300);
                res(c.getImageData(0, 0, 300, 300).data);
            };
        });
        imgBuffers.push(data);
    }
}

function initParticles() {
    const cx = canvas.width / 2, cy = canvas.height / 2;
    particles = [];
    // 手机端粒子密度优化 (步长为3)
    for (let y = 0; y < 300; y += 3) {
        for (let x = 0; x < 300; x += 3) {
            const px = x * 2.4 + (cx - 360);
            const py = y * 2.4 + (cy - 360);
            const row = y / 300;
            const tx = cx + (Math.random() - 0.5) * row * 450;
            const ty = (cy - 280) + (row * 550);
            particles.push(new Particle(px, py, tx, ty));
        }
    }
    updateColorTarget();
}

function updateColorTarget() {
    const data = imgBuffers[currentImgIdx];
    let pIdx = 0;
    for (let y = 0; y < 300; y += 3) {
        for (let x = 0; x < 300; x += 3) {
            const i = (y * 300 + x) * 4;
            if (particles[pIdx]) {
                particles[pIdx].tr = data[i];
                particles[pIdx].tg = data[i+1];
                particles[pIdx].tb = data[i+2];
            }
            pIdx++;
        }
    }
}

function animate() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
    }
    requestAnimationFrame(animate);
}

function updateTimer() {
    if (targetState === 1) return;
    const diff = new Date('2026-01-01T00:00:00') - new Date();
    const d = Math.floor(diff / 86400000);
    const h = Math.floor((diff % 86400000) / 3600000).toString().padStart(2,'0');
    const m = Math.floor((diff % 3600000) / 60000).toString().padStart(2,'0');
    const s = Math.floor((diff % 60000) / 1000).toString().padStart(2,'0');
    timerText.innerText = `${d}D ${h}:${m}:${s}`;
}
setInterval(updateTimer, 1000);

document.getElementById('btn-start').onclick = async function() {
    this.style.display = 'none';
    await loadAllImages();
    initParticles();
    animate();

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const lm = results.multiHandLandmarks[0];
            const isOpen = lm[8].y < lm[6].y && lm[12].y < lm[10].y;

            if (isOpen) {
                targetState = 1;
                timerText.className = "timer-center";
                timerText.innerText = "HAPPY 2026";
            } else {
                targetState = 0;
                timerText.className = "timer-top";

                // 针对前置摄像头的镜像逻辑
                const handX = lm[9].x;
                if (!isCooldown) {
                    if (handX > 0.8) { // 物理左边
                        currentImgIdx = (currentImgIdx - 1 + imgSources.length) % imgSources.length;
                        startTransition();
                    } else if (handX < 0.2) { // 物理右边
                        currentImgIdx = (currentImgIdx + 1) % imgSources.length;
                        startTransition();
                    }
                }
            }
        }
    });

    function startTransition() {
        isCooldown = true;
        isTransitioning = true;
        updateColorTarget();
        setTimeout(() => isTransitioning = false, 600);
        setTimeout(() => isCooldown = false, 1500);
    }

    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480,
        facingMode: 'user'
    });
    camera.start();
};
</script>
</body>
</html>
